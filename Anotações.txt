Ferramentas utilizadas: 

    Apache Maven
    JDK lts
    Docker
    IDE
    Insomnia HTTP

Aula 7
Criando nosso discovery server (Eureka):

Dependências:

    Eureka Server

Configrações importantes a principio do pom.xml:

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.6.4</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>

	<properties>
		<java.version>11</java.version> <!--Estou usando o 17-->
		<spring-cloud.version>2021.0.1</spring-cloud.version>
	</properties>

Notations: 

    @EnableEurekaServer (Na classe main)

Configurando Application.yml:

    Renomear o application.properties para application.yml

    #Vamos nomear - Pode quer qualquer nome
    spring:
    application:
        name: eurekaserver
        
    #Vamos configurar a porta    
    server:
    port: 8761

    #Dizendo ao eureka que não é para se auto-registrar, pois isso é papel do gateway
    eureka:
    client:
        register-with-eureka: false
        fetch-registry: false
  
Para acessar o eureka: http://localhost:8761

Aula 8 - 11
Criando Micro Serviço de Clientes:

Aqui vamos ter nossos endpoints do clieante

Dependências:

    Spring web
    Lombok
    Jpa
    H2 database

    Adicionais: Spring clould, Eureka client

Vamos padronixar nosso pom.xml

Vamos adicionar mais dependências no pom:

Dentro do escopo das dependências:

	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
	</dependency>

Abaixo do feclhamento da teg geral das dependências:

	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

Registrando micro serviço no eureka server

application.yml:

    #Nome que vamos refetencias o ms dentro do eureka
    spring:
    application:
        name: msclientes

    #A porta do nosso ms - A porta 0 quer dizer que vai subir em uma porta randômica para facilitar nosso trabalho de referenciar a porta    
    server:
    port: 0
    
    #Onde está meu discovery server eureka | o instance é para o spring gerar um nome aleatório do ms clientes
    eureka:
    client:
        service-url:
        defaultZone: http://localhost:8761/eureka
    instance:
        instance-id: ${spring.application.name}:${spring.application.instance_id:${random.value}} 


Notation (classe main):

    @EnableEurekaClient

Vamos criar nossa entidade (pct domain):

Notations:

    @Entity
    @Data //Lombok
    @NoArgsConstructor //Para tembém criar um construtor sem argumentos
    @Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)

Entidade:

    package io.github.cainamicael.msclientes.domain;

    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;

    import lombok.Data;
    import lombok.NoArgsConstructor;

    @Entity
    @Data
    @NoArgsConstructor
    public class Cliente {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        private String cpf;
        private String nome;
        private Integer idade;
        
        public Cliente(String cpf, String nome, Integer idade) {
            super();
            this.cpf = cpf;
            this.nome = nome;
            this.idade = idade;
        }
    }

Criando ClienteRepository (pct infra.repository):

    package io.github.cainamicael.msclientes.infra.repository;

    import java.util.Optional;

    import org.springframework.data.jpa.repository.JpaRepository;

    import io.github.cainamicael.msclientes.domain.Cliente;

    public interface ClienteRepository extends JpaRepository<Cliente, Long>{

        Optional<Cliente> findByCpf(String cpf); //Método que pedimos para criar

    }

Criando nosso DTO (pct application.representation):

    package io.github.cainamicael.msclientes.application.representation;

    import io.github.cainamicael.msclientes.domain.Cliente;
    import lombok.Data;
    import lombok.NoArgsConstructor;

    @Data
    @NoArgsConstructor
    public class ClienteSaveRequest {

        private String cpf;
        private String nome;
        private Integer idade;
        
        //Este método já transforma o dto em entidade
        public Cliente toModel() {
            return new Cliente(cpf, nome, idade);
        }
    }

Service:

    package io.github.cainamicael.msclientes.application;

    import java.util.Optional;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;

    import io.github.cainamicael.msclientes.domain.Cliente;
    import io.github.cainamicael.msclientes.infra.repository.ClienteRepository;

    @Service
    public class ClienteService {
        
        @Autowired
        private ClienteRepository repository;
        
        @Transactional
        public Cliente save(Cliente cliente) {
            return repository.save(cliente);
        }
        
        @Transactional
        public Optional<Cliente> getByCpf(String cpf){
            return repository.findByCpf(cpf);
        }
    }

Controller:

    package io.github.cainamicael.msclientes.application;

    import java.net.URI;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;
    import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

    import io.github.cainamicael.msclientes.application.representation.ClienteSaveRequest;
    import io.github.cainamicael.msclientes.domain.Cliente;

    @RestController
    @RequestMapping("clientes")
    public class ClientesController {
        
        @Autowired
        private ClienteService service;
        
        @GetMapping 
        public String status() { //Só para testar se está funcionando
            return "OK";
        }
        
        @PostMapping
        public ResponseEntity save(@RequestBody ClienteSaveRequest request) {
            Cliente cliente = request.toModel();
            service.save(cliente);
            
            
            //Construir uma url dinâmica através da url corrente - http://localhost:PORT/clientes?cpf=01234567890
            URI headerLocation = ServletUriComponentsBuilder
                    .fromCurrentRequest()
                    .query("cpf={cpf}")
                    .buildAndExpand(cliente.getCpf())
                    .toUri();

            return ResponseEntity.created(headerLocation).build();
        }

        @GetMapping(params = "cpf")
        public ResponseEntity<?> dadosCliente(@RequestParam("cpf") String cpf) {
            var cliente = service.getByCpf(cpf);
            
            if(cliente.isEmpty()) {
                return ResponseEntity.notFound().build();
            }
            
            return ResponseEntity.ok(cliente.get());
        }
    }

Métodos importantes:

    //Construir uma url dinâmica através da url corrente - http://localhost:PORT/clientes?cpf=01234567890
    URI headerLocation = ServletUriComponentsBuilder
            .fromCurrentRequest()
            .query("cpf={cpf}")
            .buildAndExpand(cliente.getCpf())
            .toUri();
    return ResponseEntity.created(headerLocation).build();

    //Este método já transforma o dto em entidade
        public Cliente toModel() {
            return new Cliente(cpf, nome, idade);
        }

Aula 12 - 13
Criação do Cloud Gateway:

Dependências:

    Spring Reactive Web (Webflux)
    Gateway
    Eureka Discovery Client

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>
    
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-gateway-dependencies</artifactId>
    </dependency>
    
    <dependency>
        <groupId>org.springframework.clould</groupId>
        <artifactId>spring-clould-starter-netflix-eureka-client</artifactId>
    </dependency>

Notation:

    @EnableEurekaClient (classe main)
    @EnableDiscoveryClient (classe main)
    @Bean (no método da classe main)

Classe main com roteamento:

    package io.github.cainamicael.msclouldgateway;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
    import org.springframework.cloud.gateway.route.RouteLocator;
    import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
    import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
    import org.springframework.context.annotation.Bean;

    @SpringBootApplication
    @EnableEurekaClient
    @EnableDiscoveryClient
    public class MscloudgatewayApplication {

        public static void main(String[] args) {
            SpringApplication.run(MsclouldgatewayApplication.class, args);
        }

        @Bean
        public RouteLocator routes(RouteLocatorBuilder builder) {
            return builder
                    .routes()
                    //Definindo rotas - Toda vez que a gente entrar nessa rota, vai ser redirecionado para a url (LoadBalancer do micro serviço), com o LoadBalancer
                    .route(r -> r.path("/clientes/**").uri("lb://msclientes")) //O ** quer dizer qq coisa que venha depois e lb é o loadbalancer
                    .build();
        }
    }

Application.yml:

    #Permite localizar os micro serviços e com letra maiuscula
    spring:
    application:
        name: mscloudgateway
    cloud:
        gateway:
        discovery:
            locator:
            enabled: true
            lower-case-service-id: true

    #Porta do Gateway
    server:
    port: 8080

    #Onde está o Eureka
    eureka:
    client:
        fetch-registry: true
        register-with-eureka: true
        service-url:
        defaultZone: http://localhost:8761/eureka

Agora podemos fazer as requisições para uma porta física, a 8080

Aula 14 - 18
Micro serviço de cartões:

Dependências:

    Lombok
    Spring Web
    Jpa
    H2 Database
    Eureka Client

Application.yml:

    #Nome da aplicação
    spring:
    application:
        name: mscartoes
        
    #Configurando porta
    server:
    port: 0
    
    #Localizando o eureka e setando nome com sufixo aleatorio - não pode esquecer do /eureka
    eureka:
    client:
        service-url:
        defaultZone: http://localhost:8761/eureka
    instance:
        instance-id: ${spring.application.name}:${spring.application.instance_id:${random.value}}

Colocar @EnableEurekaClient na classe main

Entidade:

    package io.github.cainamicael.mscartoes.domain;

    import java.math.BigDecimal;

    import javax.persistence.Entity;
    import javax.persistence.EnumType;
    import javax.persistence.Enumerated;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;

    import lombok.Data;
    import lombok.NoArgsConstructor;

    @Entity
    @Data
    @NoArgsConstructor
    public class Cartao {
        
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        private String nome;
        @Enumerated(EnumType.STRING)
        private BandeiraCartao bandeira; //Vai ser um enum
        private BigDecimal renda;
        private BigDecimal limiteBasico;
        
        public Cartao(String nome, BandeiraCartao bandeira, BigDecimal renda, BigDecimal limiteBasico) {
            super();
            this.nome = nome;
            this.bandeira = bandeira;
            this.renda = renda;
            this.limiteBasico = limiteBasico;
        }
    }

Notations: 

    @Entity
    @Data
    @NoArgsConstructor
    @Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
    @Enumerated(EnumType.STRING)

Enum:

    package io.github.cainamicael.mscartoes.domain;

    public enum BandeiraCartao {
        MASTERCARD, VISA
    }

Repository:

    package io.github.cainamicael.mscartoes.infra.repository;

    import org.springframework.data.jpa.repository.JpaRepository;

    import io.github.cainamicael.mscartoes.domain.Cartao;

    public interface CartaoRepository extends JpaRepository<Cartao, Long>{

        List<Cartao> findByRendaLessThanEqual(BigDecimal rendaBigDecimal);

    }

Service:

    package io.github.cainamicael.mscartoes.application;

    import java.math.BigDecimal;
    import java.util.List;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;

    import io.github.cainamicael.mscartoes.domain.Cartao;
    import io.github.cainamicael.mscartoes.infra.repository.CartaoRepository;

    @Service
    public class CartaoService {
        
        @Autowired
        private CartaoRepository repository;
        
        @Transactional
        public Cartao save(Cartao cartao) {
            return repository.save(cartao);
        }
        
        @Transactional
        public List<Cartao> getCartoesRendaMenorIgual(Long renda) {
            var rendaBigBecimal = BigDecimal.valueOf(renda);
            return repository.findByRendaLessThanEqual(rendaBigBecimal);
        }
        
    }

Notations:

    @Service
    @RequiredArgsConstructor
    @Transactional

Outra forma de injetar dependência, sem usar o Autowired:

    @Service
    @RequiredArgsConstructor
    public class CartaoService {
        
        private final CartaoRepository repository;

    }

Resource(Controller):

    package io.github.cainamicael.mscartoes.application;

    import java.util.List;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;

    import io.github.cainamicael.mscartoes.domain.Cartao;
    import io.github.cainamicael.mscartoes.representation.CartaoSavaRequest;

    @RestController
    @RequestMapping("cartoes")
    public class CartoesResource {
        
        @Autowired
        private CartaoService service;
        
        @GetMapping
        public String status() {
            return "OK";
        }
        
        @PostMapping
        public ResponseEntity<?> cadastra(@RequestBody CartaoSavaRequest request) {
            Cartao cartao = request.toModel();
            service.save(cartao);
            return ResponseEntity.status(HttpStatus.CREATED).build();
        }
        
        @GetMapping(params = "renda")
        public ResponseEntity<List<Cartao>> getCartoesRendaAte(@RequestParam("renda") Long renda ) {
            List<Cartao> list = service.getCartoesRendaMenorIgual(renda);
            return ResponseEntity.ok(list);
        }
    }

Aula 19:
Novo endpoint. Vamos precisar de uma nova entidade

Dizendo que cartão cada cliente vai ter:

Listando cartões pelo cliente:

Nova entidade, cartão cliente:

    package io.github.cainamicael.mscartoes.domain;

    import java.math.BigDecimal;

    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;
    import javax.persistence.JoinColumn;
    import javax.persistence.ManyToOne;

    import lombok.Data;
    import lombok.NoArgsConstructor;

    @Entity
    @Data
    @NoArgsConstructor
    public class ClienteCartao {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        private String cpf;
        
        @ManyToOne
        @JoinColumn(name = "id_cartao")
        private Cartao cartao;
        
        private BigDecimal limite;
    }

Repository:

    package io.github.cainamicael.mscartoes.infra.repository;

    import java.util.List;

    import org.springframework.data.jpa.repository.JpaRepository;

    import io.github.cainamicael.mscartoes.domain.ClienteCartao;

    public interface ClienteCartaoRepository extends JpaRepository<ClienteCartao, Long>{

        List<ClienteCartao> findByCpf(String cpf);
    }

Service:

    package io.github.cainamicael.mscartoes.application;

    import java.util.List;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;

    import io.github.cainamicael.mscartoes.domain.ClienteCartao;
    import io.github.cainamicael.mscartoes.infra.repository.ClienteCartaoRepository;

    @Service
    public class ClienteCartaoService {
        
        @Autowired
        private ClienteCartaoRepository repository;
        
        private List<ClienteCartao> listCartoesByCpf(String cpf) {
            return repository.findByCpf(cpf);
        }

    }

DTO CartaoPorClienteResponse:

    package io.github.cainamicael.mscartoes.representation;

    import java.math.BigDecimal;

    import io.github.cainamicael.mscartoes.domain.ClienteCartao;
    import lombok.AllArgsConstructor;
    import lombok.Data;
    import lombok.NoArgsConstructor;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public class CartaoPorClienteResponse {

        private String nome;
        private String bandeira;
        private BigDecimal limiteLiberado;
        
        public static CartaoPorClienteResponse fromModel(ClienteCartao model) {
            return new CartaoPorClienteResponse(
                model.getCartao().getNome(),
                model.getCartao().getBandeira().toString(),
                model.getLimite()
            );
        }
        
    }

Controller (Mesmo resource que já existe, só adicionar o método):

	@GetMapping(params = "cpf")
	public ResponseEntity<List<CartaoPorClienteResponse>> getCartoesByCliente(@RequestParam("cpf") String cpf) {
		List<ClienteCartao> lista = clienteCartaoService.listCartoesByCpf(cpf);
		List<CartaoPorClienteResponse> resultList = lista.stream().map(CartaoPorClienteResponse::fromModel).collect(Collectors.toList());
		return ResponseEntity.ok(resultList);
	}

Aula 20-25
Registrando MSCartoes no Gateway:

    .route(r -> r.path("/cartoes/**").uri("lb://mscartoes"))    

Aula 21
Implementando micro serviço avaliador de crédito, que vai se comunicar com os outros ms:

Dependências:

    Spring Web
    Lombok
    Eureka discovery client
    OpenFeign

Application.yml:

    spring:
    application:
        name: msavaliadorcredito
        
    server:
    port: 0
    
    eureka:
    client:
        service-url:
        defaultZone: http://localhost:8761/eureka
    instance:
        instance-id: ${spring.application.name}:${spring.application.instance_id:${random.value}}

Notation:

    @EnableEurekaClient(classe main)

Roteando no Gateway:

    .route(r -> r.path("/avaliacoes-credito/**").uri("lb://msavaliadorcredito"))

Configurando OpenFeign:

Notations:

    @EnableFeignClients(classe main)
    @FeignClient(url = "http://localhost:8080", path = "/clientes") //Na interface - este é só um exemplo. Esta notation não usa o loadbalancer. Vamos usar a notation Abaixo
    @FeignClient(value = "msclientes", path = "/clientes") //Estamos referenciando o ms e o endpoint

Interface (Que se comunica com o msclientes): 

    package cio.github.cainamicael.msavaliadorcredito.infra.clients;

    import org.springframework.cloud.openfeign.FeignClient;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestParam;

    import cio.github.cainamicael.msavaliadorcredito.domain.model.DadosCliente;

    @FeignClient(value = "msclientes", path = "/clientes") //Estamos referenciando o ms e o endpoint
    public interface ClienteResourceClient {
        
        //Só precisamos colocar a assinatura do método que vamos usar para obter os dados via endpoint
        @GetMapping(params = "cpf")
        ResponseEntity<DadosCliente> dadosCliente(@RequestParam("cpf") String cpf);

    }

Interface que se comunica com o mscartoes:

    package cio.github.cainamicael.msavaliadorcredito.infra.clients;

    import java.util.List;

    import org.springframework.cloud.openfeign.FeignClient;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestParam;

    import cio.github.cainamicael.msavaliadorcredito.domain.model.CartaoCliente;

    @FeignClient(value = "mscartoes", path = "/cartoes")
    public interface CartoesResourceClient {
        
        @GetMapping(params = "cpf")
        ResponseEntity<List<CartaoCliente>> getCartoesByCliente(@RequestParam("cpf") String cpf);

    }

Aula 26
Tratando erros da comunicação

Classe 1:

    package cio.github.cainamicael.msavaliadorcredito.application.ex;

    public class DadosClienteNotFoundException extends Exception{
        
        public DadosClienteNotFoundException() {
            super("Dados do cliente não encontrados para o cpf informado");
        }
        
    }

Classe 2:

    package cio.github.cainamicael.msavaliadorcredito.application.ex;

    import lombok.Getter;

    public class ErroComunicacaoMicroservicesException extends Exception {
        
        @Getter
        private Integer status;

        public ErroComunicacaoMicroservicesException(String msg, Integer status) {
            super(msg);
            this.status = status;
        }
    }

Service:

	public SituacaoCliente obterSituacaoCliente(String cpf) throws DadosClienteNotFoundException, ErroComunicacaoMicroservicesException {
		//precisamos consultar o msclientes para obter os dados - vamos usar OpenFeign
		
		//Comunicação síncrona com o mscliente
		try {
			ResponseEntity<DadosCliente> dadosClienteResponse = clienteClient.dadosCliente(cpf);
			
			//Comunicação síncrona com o mscartoes
			ResponseEntity<List<CartaoCliente>> cartoesResponse = cartoesClient.getCartoesByCliente(cpf);
			
			return SituacaoCliente
					.builder()
					.cliente(dadosClienteResponse.getBody())
					.cartoes(cartoesResponse.getBody())
					.build(); //Pegar apenas a informação do ResponseEntity	
		} catch (FeignException.FeignClientException e) {
			int status = e.status();
			
			if(HttpStatus.NOT_FOUND.value() == status) {
				throw new DadosClienteNotFoundException();
			}
			
			throw new ErroComunicacaoMicroservicesException(cpf, status);
		}
	}

Controller:

    @GetMapping(value = "situacao-cliente", params = "cpf")
	public ResponseEntity<?> consultaSituacaoCliente(@RequestParam("cpf") String cpf) {
		try {
			SituacaoCliente situacaoCliente = avaliadorCreditoService.obterSituacaoCliente(cpf);
			return ResponseEntity.ok(situacaoCliente);
			
		} catch (DadosClienteNotFoundException e) {
			// TODO Auto-generated catch block
			return ResponseEntity.notFound().build();
		} catch (ErroComunicacaoMicroservicesException e) {
			// TODO Auto-generated catch block
			return ResponseEntity.status(HttpStatus.resolve(e.getStatus())).body(e.getMessage());
		}
	}

Aula 27:
Implementando avaliação do cliente com regra de negócio:

Service:

    package cio.github.cainamicael.msavaliadorcredito.application;

    import java.math.BigDecimal;
    import java.util.List;
    import java.util.stream.Collectors;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.stereotype.Service;

    import cio.github.cainamicael.msavaliadorcredito.application.ex.DadosClienteNotFoundException;
    import cio.github.cainamicael.msavaliadorcredito.application.ex.ErroComunicacaoMicroservicesException;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.Cartao;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.CartaoAprovado;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.CartaoCliente;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.DadosCliente;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.RetornoAvaliacaoCliente;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.SituacaoCliente;
    import cio.github.cainamicael.msavaliadorcredito.infra.clients.CartoesResourceClient;
    import cio.github.cainamicael.msavaliadorcredito.infra.clients.ClienteResourceClient;
    import feign.FeignException;
    import lombok.RequiredArgsConstructor;

    @Service
    @RequiredArgsConstructor
    public class AvaliadorCreditoService {
        
        @Autowired
        private ClienteResourceClient clienteClient;
        
        @Autowired
        private CartoesResourceClient cartoesClient;

        
        public SituacaoCliente obterSituacaoCliente(String cpf) throws DadosClienteNotFoundException, ErroComunicacaoMicroservicesException {
            //precisamos consultar o msclientes para obter os dados - vamos usar OpenFeign
            
            //Comunicação síncrona com o mscliente
            try {
                ResponseEntity<DadosCliente> dadosClienteResponse = clienteClient.dadosCliente(cpf);
                
                //Comunicação síncrona com o mscartoes
                ResponseEntity<List<CartaoCliente>> cartoesResponse = cartoesClient.getCartoesByCliente(cpf);
                
                return SituacaoCliente
                        .builder()
                        .cliente(dadosClienteResponse.getBody())
                        .cartoes(cartoesResponse.getBody())
                        .build(); //Pegar apenas a informação do ResponseEntity	
            } catch (FeignException.FeignClientException e) {
                int status = e.status();
                
                if(HttpStatus.NOT_FOUND.value() == status) {
                    throw new DadosClienteNotFoundException();
                }
                
                throw new ErroComunicacaoMicroservicesException(cpf, status);
            }
        }
        
        public RetornoAvaliacaoCliente realizarAvaliacao (String cpf, Long renda) throws DadosClienteNotFoundException, ErroComunicacaoMicroservicesException {
            try {
                ResponseEntity<DadosCliente> dadosClienteResponse = clienteClient.dadosCliente(cpf);
                ResponseEntity<List<Cartao>> cartoesResponse = cartoesClient.getCartoesRendaAte(renda);
                
                List<Cartao> cartoes = cartoesResponse.getBody();
                List<CartaoAprovado> listaCartoesAprovados = cartoes.stream().map((Cartao cartao) -> {
                    DadosCliente dadosCliente = dadosClienteResponse.getBody();
                    BigDecimal limiteBasico = cartao.getLimiteBasico();
                    BigDecimal idadeBD = BigDecimal.valueOf(dadosCliente.getIdade());

                    var fator = idadeBD.divide(BigDecimal.valueOf(10));
                    BigDecimal limiteAprovado = fator.multiply(limiteBasico);

                    CartaoAprovado aprovado = new CartaoAprovado();
                    aprovado.setCartao(cartao.getNome());
                    aprovado.setBandeira(cartao.getBandeira());
                    aprovado.setLimiteAprovado(limiteAprovado);

                    return aprovado;
                }).collect(Collectors.toList());
                
                return new RetornoAvaliacaoCliente(listaCartoesAprovados);
            }  catch (FeignException.FeignClientException e) {
                int status = e.status();
                
                if(HttpStatus.NOT_FOUND.value() == status) {
                    throw new DadosClienteNotFoundException();
                }
        
                throw new ErroComunicacaoMicroservicesException(cpf, status);
            }
        }
    }

Controller:

    package cio.github.cainamicael.msavaliadorcredito.application;


    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;

    import cio.github.cainamicael.msavaliadorcredito.application.ex.DadosClienteNotFoundException;
    import cio.github.cainamicael.msavaliadorcredito.application.ex.ErroComunicacaoMicroservicesException;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.DadosAvaliacao;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.RetornoAvaliacaoCliente;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.SituacaoCliente;

    @RestController
    @RequestMapping("avaliacoes-credito")
    public class AvaliadorCreditoController {
        
        @Autowired
        private AvaliadorCreditoService avaliadorCreditoService;
        
        @GetMapping
        public String status() {
            return "OK";
        }
        
        @GetMapping(value = "situacao-cliente", params = "cpf")
        public ResponseEntity<?> consultaSituacaoCliente(@RequestParam("cpf") String cpf) {
            try {
                SituacaoCliente situacaoCliente = avaliadorCreditoService.obterSituacaoCliente(cpf);
                return ResponseEntity.ok(situacaoCliente);
            } catch (DadosClienteNotFoundException e) {
                // TODO Auto-generated catch block
                return ResponseEntity.notFound().build();
            } catch (ErroComunicacaoMicroservicesException e) {
                // TODO Auto-generated catch block
                return ResponseEntity.status(HttpStatus.resolve(e.getStatus())).body(e.getMessage());
            }
        }
        
        @PostMapping
        public ResponseEntity realizarAvaliacao(@RequestBody DadosAvaliacao dados) {
            try {
                RetornoAvaliacaoCliente retornoAvaliacaoCliente = avaliadorCreditoService.realizarAvaliacao(dados.getCpf(), dados.getRenda());
                return ResponseEntity.ok(retornoAvaliacaoCliente);
            } catch (DadosClienteNotFoundException e) {
                // TODO Auto-generated catch block
                return ResponseEntity.notFound().build();
            } catch (ErroComunicacaoMicroservicesException e) {
                // TODO Auto-generated catch block
                return ResponseEntity.status(HttpStatus.resolve(e.getStatus())).body(e.getMessage());
            }	
        }
    }

Resource (FeignClient):

    package cio.github.cainamicael.msavaliadorcredito.infra.clients;

    import java.util.List;

    import org.springframework.cloud.openfeign.FeignClient;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestParam;

    import cio.github.cainamicael.msavaliadorcredito.domain.model.Cartao;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.CartaoCliente;

    @FeignClient(value = "mscartoes", path = "/cartoes")
    public interface CartoesResourceClient {
        
        @GetMapping(params = "cpf")
        ResponseEntity<List<CartaoCliente>> getCartoesByCliente(@RequestParam("cpf") String cpf);
        
        @GetMapping(params = "renda")
        ResponseEntity<List<Cartao>> getCartoesRendaAte(@RequestParam("renda") Long renda);

    }

Aula 30
Mensageria:

Iremos usar o RabbitMQ

RabbitMQ via docker:

Scripc retirado do site do RabbitMQ:

docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.12-management

    docker run = Serve para rodar uma imagem docker - Cria um container
    -it = Modo interativo. Posso ficar interagindo com o container na linha de comando
    -rm = Quando eu encerrar o processo, ele vai destruir o container (Não vamos usar esta opção)
    --name rabbitmq = Dizendo que vou nomear o container, e em seguida já coloco o nome que eu quero
    -p 5672 (Porta exposta) : 5672 (Porta do container) = Dizendo que vai rodar em uma porta e expondo a porta
    -p 15672:15672 = Porta do administrador - Onde iremos acessar a interface gráfica
    rabbitmq:3.12-management = Imagem usada para startar o container

Ficará assim: docker run -it --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.12-management

Acessando interface gráfica: 

    localhost:15672
    username: guest
    password: guest

Aula 32 
Criando Subscriber(quem vai ouvir/receber as mensagens) para fila de emissão de cartões (MSCLIENTES): 

Para usar o rabbitmq no meu ms, preciso adicionar a dependencia amqp:

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-amqp</artifactId>
    </dependency>

Vamos agora criar a fila de emissão de cartões no painel do rabbitmq:

    Type: classic
    Name: emissao-cartoes

Conectando com o rabbitmq:

    #Nome da aplicação e conexão com rabbitmq (application.yml):
    spring:
    application:
        name: mscartoes
    rabbitmq:
        host: localhost
        port: 5672
        username: guest
        password: guest

Referenciando fila no ms (application.yml):

    #Configurando a fila
    mq:
        queues:
            emissao-cartoes: emissao-cartoes

Notations:

    @EnableRabbit (classe main)
    @Component (na classe que vamos usar para escutar as mensagens do rabbitmq)
    @RabbitListener(queues = "${mq.queues.emissao-cartoes}")
    @Payload

Classe que vai escutar as mensagens:

    package io.github.cainamicael.mscartoes.infra.mqueue;

    import org.springframework.amqp.rabbit.annotation.RabbitListener;
    import org.springframework.messaging.handler.annotation.Payload;
    import org.springframework.stereotype.Component;

    @Component
    public class EmissaoCartaoSubscriver {

        @RabbitListener(queues = "${mq.queues.emissao-cartoes}")
        public void receberSolicitacaoEmissao(@Payload String payload) {
            System.out.println(payload);
        }
    }

Aula 33
Criando publisher (quem vai publicar a mensagem - MSAVALIADORCREDITO):

dependência:

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-amqp</artifactId>
        </dependency>

Conectando com o rabbitmq:

    #Nome da aplicação e conexão com rabbitmq (application.yml):
    spring:
    application:
        name: mscartoes
    rabbitmq:
        host: localhost
        port: 5672
        username: guest
        password: guest

Referenciando fila no ms (application.yml):

    #Configurando a fila
    mq:
        queues:
            emissao-cartoes: emissao-cartoes

Notation:

    @EnableRabbit (classe main)

Classe de configuracao (pct config):

    package cio.github.cainamicael.msavaliadorcredito.config;

    import org.springframework.amqp.core.Queue;
    import org.springframework.beans.factory.annotation.Value;
    import org.springframework.context.annotation.Configuration;

    @Configuration
    public class MQConfig {
        
        @Value("${mq.queues.emissao-cartoes}")
        private String emissaoCartoesFila;

        @Bean
        public Queue queueEmissaoCartoes() {
            return new Queue(emissaoCartoesFila, true);
        }
        
    }

Classe para o publisher:

    package cio.github.cainamicael.msavaliadorcredito.infra.mqueue;

    import org.springframework.amqp.core.Queue;
    import org.springframework.amqp.rabbit.core.RabbitTemplate;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Component;

    import com.fasterxml.jackson.core.JsonProcessingException;
    import com.fasterxml.jackson.databind.ObjectMapper;

    import cio.github.cainamicael.msavaliadorcredito.domain.model.DadosSolicitacaoEmissaoCartao;

    @Component
    public class SolicitacaoEmissaoCartaoPublisher {

        @Autowired
        private RabbitTemplate rabbitTemplate;
        
        @Autowired
        private Queue queueEmissaoCartoes; //Injeta a fila que criamos na configuracao
        
        
        public void solicitarCartao(DadosSolicitacaoEmissaoCartao dados) throws JsonProcessingException {
            var json = convertIntoJson(dados);
            rabbitTemplate.convertAndSend(queueEmissaoCartoes.getName(), json); //A fila e o json
        }
        
        //Vamos transformar nosso objeto de parâmetro em json
        private String convertIntoJson(DadosSolicitacaoEmissaoCartao dados) throws JsonProcessingException {
            ObjectMapper mapper = new ObjectMapper();
            var json = mapper.writeValueAsString(dados);
            return json;
        }
    }

Classe DadosSolicitacaoEmissaoCartao:

    import java.math.BigDecimal;

    import lombok.Data;

    @Data
    public class DadosSolicitacaoEmissaoCartao {
        
        private Long idCartao;
        private String cpf;
        private String endereco;
        private BigDecimal limiteLiberado;

    }

Método no service:

    public ProtocoloSolicitacaoCartao solicitarEmissaoCartao(DadosSolicitacaoEmissaoCartao dados) {
		try {
			emissaoCartaoPublisher.solicitarCartao(dados);
			var protocolo = UUID.randomUUID().toString();
			return new ProtocoloSolicitacaoCartao(protocolo);
		} catch (Exception e) {
			throw new ErroSolicitacaoCartaoException(e.getMessage());
		}
	}

Método no controller:

    @PostMapping("solicitacoes-cartao")
	public ResponseEntity<?> solicitarCartao(@RequestBody DadosSolicitacaoEmissaoCartao dados) {
		try {
			ProtocoloSolicitacaoCartao protocolo = avaliadorCreditoService.solicitarEmissaoCartao(dados);
			return ResponseEntity.ok(protocolo);
		} catch (Exception e) {
			return ResponseEntity.internalServerError().body(e.getMessage());
		}
	}

Completando o ouvinte (MSCARTOES - Tipando os resultados e persistindo no bd):

    package io.github.cainamicael.mscartoes.infra.mqueue;

    import org.springframework.amqp.rabbit.annotation.RabbitListener;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.messaging.handler.annotation.Payload;
    import org.springframework.stereotype.Component;

    import com.fasterxml.jackson.databind.ObjectMapper;

    import io.github.cainamicael.mscartoes.domain.Cartao;
    import io.github.cainamicael.mscartoes.domain.ClienteCartao;
    import io.github.cainamicael.mscartoes.domain.DadosSolicitacaoEmissaoCartao;
    import io.github.cainamicael.mscartoes.infra.repository.CartaoRepository;
    import io.github.cainamicael.mscartoes.infra.repository.ClienteCartaoRepository;

    @Component
    public class EmissaoCartaoSubscriver {
        
        @Autowired
        private CartaoRepository repository;
        
        @Autowired
        private ClienteCartaoRepository clienteCartaoRepository;

        @RabbitListener(queues = "${mq.queues.emissao-cartoes}")
        public void receberSolicitacaoEmissao(@Payload String payload) {
            try {
                //Vamos transformar a string que recebemos em um objeto DadosSolicitacaoEmissaoCartao
                var mapper = new ObjectMapper();
                DadosSolicitacaoEmissaoCartao dados = mapper.readValue(payload, DadosSolicitacaoEmissaoCartao.class);
                
                Cartao cartao = repository.findById(dados.getIdCartao()).orElseThrow();
                ClienteCartao clienteCartao = new ClienteCartao();
                clienteCartao.setCartao(cartao);
                clienteCartao.setCpf(dados.getCpf());
                clienteCartao.setLimite(dados.getLimiteLiberado());
                
                clienteCartaoRepository.save(clienteCartao);
            } catch(Exception e) {
                e.printStackTrace();
            }
        }
    }




















Segurança da nossa api:

Iremos usar o keycloak para criarmos um tokem jwt, e vamos ter as features do oauth2

Levantando keycloak via docker:

    docker run -p 8080:8080 -e KEYCLOAK_ADMIN=admin -e KEYCLOAK_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak:22.0.1 start-dev

    -e = Variáveis de ambiente

    Vamos mudar a porta externa para 8081, pois nossa api já roda na porta 8080

    docker run --name cursomskeycloak -p 8081:8080 -e KEYCLOAK_ADMIN=admin -e KEYCLOAK_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak:22.0.1 start-dev

Acesso: http://localhost:8081

Vamos agora criar nosso realm e criar um client

Client Authentication e Authorization deixar enable

Valid redirect URIs: http://localhost:8080 (Link da api)

Configurando nosso gateway com o keyclock:

Dependências:

    OAuth2 Resource Server

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>

Application.yml:

    spring:
    application:
        name: mscloudgateway
    cloud:
        gateway:
        discovery:
            locator:
            enabled: true
            lower-case-service-id: true
    security:
        oauth2:
        resourceserver:
            jwt:
            issuer-uri: http://localhost:8081/realms/mscourserealm #Onde irá validar o token

Testando nosso token:

    OAuth 2
    Grant Type: Client Credentials
    Acess token url: http://localhost:8081/realms/mscourserealm/protocol/openid-connect/token (Realm settings / primeito link / no json escolhe token endpoint)
    Client id: mscredito
    crecentials: clients / credentials / client secret

token: eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICJ5clQtODZ4a3BudDdjYmJraDJoQVJaWW1KTElEU1VETzhNSHZTeFd4N0VvIn0.eyJleHAiOjE2OTE3MDQ2NDAsImlhdCI6MTY5MTcwNDM0MCwianRpIjoiZjQxMjdiMzEtNWM4Mi00ZWU3LTgzYTUtNzgyOTk0MzEwZTlhIiwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDo4MDgxL3JlYWxtcy9tc2NvdXJzZXJlYWxtIiwiYXVkIjoiYWNjb3VudCIsInN1YiI6ImQ4Y2VhYzU1LWI3MTctNDZjMS1iOTliLTU5MGVlZGM1NjM5MCIsInR5cCI6IkJlYXJlciIsImF6cCI6Im1zY3JlZGl0byIsImFjciI6IjEiLCJhbGxvd2VkLW9yaWdpbnMiOlsiaHR0cDovL2xvY2FsaG9zdDo4MDgwIl0sInJlYWxtX2FjY2VzcyI6eyJyb2xlcyI6WyJkZWZhdWx0LXJvbGVzLW1zY291cnNlcmVhbG0iLCJvZmZsaW5lX2FjY2VzcyIsInVtYV9hdXRob3JpemF0aW9uIl19LCJyZXNvdXJjZV9hY2Nlc3MiOnsibXNjcmVkaXRvIjp7InJvbGVzIjpbInVtYV9wcm90ZWN0aW9uIl19LCJhY2NvdW50Ijp7InJvbGVzIjpbIm1hbmFnZS1hY2NvdW50IiwibWFuYWdlLWFjY291bnQtbGlua3MiLCJ2aWV3LXByb2ZpbGUiXX19LCJzY29wZSI6InByb2ZpbGUgZW1haWwiLCJlbWFpbF92ZXJpZmllZCI6ZmFsc2UsImNsaWVudEhvc3QiOiIxNzIuMTcuMC4xIiwicHJlZmVycmVkX3VzZXJuYW1lIjoic2VydmljZS1hY2NvdW50LW1zY3JlZGl0byIsImNsaWVudEFkZHJlc3MiOiIxNzIuMTcuMC4xIiwiY2xpZW50X2lkIjoibXNjcmVkaXRvIn0.r8IsGnraqk-lCsikiSKLcQBSv2t7U_qnY10gAvX-SDAlSxGn8MKqvgAuLjgl_uCLsV-568BrWoj3mWUDhOjOttvnban7cQ-3Fng-o_b5rM83LD3_jEDPE_OIb2wrRGRqaTM5IClYOfkkVL2a0JMBnE5c-Kfv9AzAEjfqjkrFIyo5VpRLZKPwr9PxJP2oPxATbuHm16roaGCpY1ZvXIEjoo-XooklBwrXaDCo2TsBCPpXxH-EhU635rgGcshmGQykpojomzkNVzBklejr-DQkFIZHC04lERKzfrEMplEHsZuRvyZGMmmosqB5KTA9RsZY-YSrubFmTyQ5nEK1eRB28g

Para decodificar, vamos no jwt.io

Vamos nos nossos endpoints do postman e colamos o token - BEARER TOKEN

Segurança do nosso Discovery Server:

Temos que evitar que qualquer micro serviço se conecte no nosso eureka

Dependências:

    Spring Security

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-security</artifactId>
    </dependency>

Application.yml:

    spring:
    application:
        name: eurekaserver
    security:
        basic:
        enabled: true
        user:
        name: cursoms-eureka-user
        password: smu-sroekreuurac-es

Classe de configuração:

Notations: 

    @EnableWebSecurity

Classe:

    package io.github.cainamicael.eurekaserver;

    import org.springframework.security.config.annotation.web.builders.HttpSecurity;
    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

    @EnableWebSecurity
    public class SecurityConfig extends WebSecurityConfigurerAdapter{
        
        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                .csrf().disable() //Porque não estamos usando formulário
                .authorizeHttpRequests().anyRequest().authenticated() //Dizendo que qualquer requisição, precisa-se de uma autenticação
                .and()
                .httpBasic(); //Autenticação básica
        }

    }

Nosso eureka já está protegido!

Configurando microservices para se logar no eureka:

Application.yml:

Vamos mudar o dafaultZone para: http://usuario:senha@localhost:8761/eureka

    #Localizando o eureka e setando nome com sufixo aleatorio - não pode esquecer do /eureka
    eureka:
    client:
        service-url:
        defaultZone: http://cursoms-eureka-user:smu-sroekreuurac-es@localhost:8761/eureka
    instance:
        instance-id: ${spring.application.name}:${spring.application.instance_id:${random.value}}

Vamos replicar em todos os nossos microservices

Log no EmissaoCartaoSubscriver:

Notation:

    @Slf4j

Classe:

    package io.github.cainamicael.mscartoes.infra.mqueue;

    import org.springframework.amqp.rabbit.annotation.RabbitListener;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.messaging.handler.annotation.Payload;
    import org.springframework.stereotype.Component;

    import com.fasterxml.jackson.databind.ObjectMapper;

    import io.github.cainamicael.mscartoes.domain.Cartao;
    import io.github.cainamicael.mscartoes.domain.ClienteCartao;
    import io.github.cainamicael.mscartoes.domain.DadosSolicitacaoEmissaoCartao;
    import io.github.cainamicael.mscartoes.infra.repository.CartaoRepository;
    import io.github.cainamicael.mscartoes.infra.repository.ClienteCartaoRepository;
    import lombok.extern.slf4j.Slf4j;

    @Component
    @Slf4j
    public class EmissaoCartaoSubscriver {
        
        @Autowired
        private CartaoRepository repository;
        
        @Autowired
        private ClienteCartaoRepository clienteCartaoRepository;

        @RabbitListener(queues = "${mq.queues.emissao-cartoes}")
        public void receberSolicitacaoEmissao(@Payload String payload) {
            try {
                //Vamos transformar a string que recebemos em um objeto DadosSolicitacaoEmissaoCartao
                var mapper = new ObjectMapper();
                DadosSolicitacaoEmissaoCartao dados = mapper.readValue(payload, DadosSolicitacaoEmissaoCartao.class);
                
                Cartao cartao = repository.findById(dados.getIdCartao()).orElseThrow();
                ClienteCartao clienteCartao = new ClienteCartao();
                clienteCartao.setCartao(cartao);
                clienteCartao.setCpf(dados.getCpf());
                clienteCartao.setLimite(dados.getLimiteLiberado());
                
                clienteCartaoRepository.save(clienteCartao);
            } catch(Exception e) {
                log.error("Erro ao receber solicitação de emissão de cartão: {}", e.getMessage());
            }
        }
    }

Actuator, métricas e logs:

Atuador (/actuator/info):

Dependência - Nos microservices:

    Actuator

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>

Application.yml:

    # Expondo todos os endpoints do actuator
    management:
    endpoints:
        web:
        exposure:
            include: '*'

    # Criando nosso arquivo de log
    logging:
    file:
        name: ./logs/log-file.log

Para mais endpoints, usar a rota /actuator
AVISO: Não compartilhamos essas informações no gateway!

Open Api e Swagger UI - Documentação da api:

Dependência (https://springdoc.org/): 

    <dependency>
        <groupId>org.springdoc</groupId>
        <artifactId>springdoc-openapi-ui</artifactId>
        <version>1.6.8</version>
    </dependency>

Endpoint correspondente: /swagger-ui/index.html