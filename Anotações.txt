Ferramentas utilizadas: 

    Apache Maven
    JDK lts
    Docker
    IDE
    Insomnia HTTP

Aula 7
Criando nosso discovery server (Eureka):

Dependências:

    Eureka Server

Configrações importantes a principio do pom.xml:

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.6.4</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>

	<properties>
		<java.version>11</java.version> <!--Estou usando o 17-->
		<spring-cloud.version>2021.0.1</spring-cloud.version>
	</properties>

Notations: 

    @EnableEurekaServer (Na classe main)

Configurando Application.yml:

    Renomear o application.properties para application.yml

    #Vamos nomear - Pode quer qualquer nome
    spring:
    application:
        name: eurekaserver
        
    #Vamos configurar a porta    
    server:
    port: 8761

    #Dizendo ao eureka que não é para se auto-registrar, pois isso é papel do gateway
    eureka:
    client:
        register-with-eureka: false
        fetch-registry: false
  
Para acessar o eureka: http://localhost:8761

Aula 8 - 11
Criando Micro Serviço de Clientes:

Aqui vamos ter nossos endpoints do clieante

Dependências:

    Spring web
    Lombok
    Jpa
    H2 database

    Adicionais: Spring clould, Eureka client

Vamos padronixar nosso pom.xml

Vamos adicionar mais dependências no pom:

Dentro do escopo das dependências:

	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
	</dependency>

Abaixo do feclhamento da teg geral das dependências:

	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

Registrando micro serviço no eureka server

application.yml:

    #Nome que vamos refetencias o ms dentro do eureka
    spring:
    application:
        name: msclientes

    #A porta do nosso ms - A porta 0 quer dizer que vai subir em uma porta randômica para facilitar nosso trabalho de referenciar a porta    
    server:
    port: 0
    
    #Onde está meu discovery server eureka | o instance é para o spring gerar um nome aleatório do ms clientes
    eureka:
    client:
        service-url:
        defaultZone: http://localhost:8761/eureka
    instance:
        instance-id: ${spring.application.name}:${spring.application.instance_id:${random.value}} 


Notation (classe main):

    @EnableEurekaClient

Vamos criar nossa entidade (pct domain):

Notations:

    @Entity
    @Data //Lombok
    @NoArgsConstructor //Para tembém criar um construtor sem argumentos
    @Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)

Entidade:

    package io.github.cainamicael.msclientes.domain;

    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;

    import lombok.Data;
    import lombok.NoArgsConstructor;

    @Entity
    @Data
    @NoArgsConstructor
    public class Cliente {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        private String cpf;
        private String nome;
        private Integer idade;
        
        public Cliente(String cpf, String nome, Integer idade) {
            super();
            this.cpf = cpf;
            this.nome = nome;
            this.idade = idade;
        }
    }

Criando ClienteRepository (pct infra.repository):

    package io.github.cainamicael.msclientes.infra.repository;

    import java.util.Optional;

    import org.springframework.data.jpa.repository.JpaRepository;

    import io.github.cainamicael.msclientes.domain.Cliente;

    public interface ClienteRepository extends JpaRepository<Cliente, Long>{

        Optional<Cliente> findByCpf(String cpf); //Método que pedimos para criar

    }

Criando nosso DTO (pct application.representation):

    package io.github.cainamicael.msclientes.application.representation;

    import io.github.cainamicael.msclientes.domain.Cliente;
    import lombok.Data;
    import lombok.NoArgsConstructor;

    @Data
    @NoArgsConstructor
    public class ClienteSaveRequest {

        private String cpf;
        private String nome;
        private Integer idade;
        
        //Este método já transforma o dto em entidade
        public Cliente toModel() {
            return new Cliente(cpf, nome, idade);
        }
    }

Service:

    package io.github.cainamicael.msclientes.application;

    import java.util.Optional;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;

    import io.github.cainamicael.msclientes.domain.Cliente;
    import io.github.cainamicael.msclientes.infra.repository.ClienteRepository;

    @Service
    public class ClienteService {
        
        @Autowired
        private ClienteRepository repository;
        
        @Transactional
        public Cliente save(Cliente cliente) {
            return repository.save(cliente);
        }
        
        @Transactional
        public Optional<Cliente> getByCpf(String cpf){
            return repository.findByCpf(cpf);
        }
    }

Controller:

    package io.github.cainamicael.msclientes.application;

    import java.net.URI;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;
    import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

    import io.github.cainamicael.msclientes.application.representation.ClienteSaveRequest;
    import io.github.cainamicael.msclientes.domain.Cliente;

    @RestController
    @RequestMapping("clientes")
    public class ClientesController {
        
        @Autowired
        private ClienteService service;
        
        @GetMapping 
        public String status() { //Só para testar se está funcionando
            return "OK";
        }
        
        @PostMapping
        public ResponseEntity save(@RequestBody ClienteSaveRequest request) {
            Cliente cliente = request.toModel();
            service.save(cliente);
            
            
            //Construir uma url dinâmica através da url corrente - http://localhost:PORT/clientes?cpf=01234567890
            URI headerLocation = ServletUriComponentsBuilder
                    .fromCurrentRequest()
                    .query("cpf={cpf}")
                    .buildAndExpand(cliente.getCpf())
                    .toUri();

            return ResponseEntity.created(headerLocation).build();
        }

        @GetMapping(params = "cpf")
        public ResponseEntity<?> dadosCliente(@RequestParam("cpf") String cpf) {
            var cliente = service.getByCpf(cpf);
            
            if(cliente.isEmpty()) {
                return ResponseEntity.notFound().build();
            }
            
            return ResponseEntity.ok(cliente.get());
        }
    }

Métodos importantes:

    //Construir uma url dinâmica através da url corrente - http://localhost:PORT/clientes?cpf=01234567890
    URI headerLocation = ServletUriComponentsBuilder
            .fromCurrentRequest()
            .query("cpf={cpf}")
            .buildAndExpand(cliente.getCpf())
            .toUri();
    return ResponseEntity.created(headerLocation).build();

    //Este método já transforma o dto em entidade
        public Cliente toModel() {
            return new Cliente(cpf, nome, idade);
        }

Aula 12
Criação do Clould Gateway:

