Ferramentas utilizadas: 

    Apache Maven
    JDK lts
    Docker
    IDE
    Insomnia HTTP

Aula 7
Criando nosso discovery server (Eureka):

Dependências:

    Eureka Server

Configrações importantes a principio do pom.xml:

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.6.4</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>

	<properties>
		<java.version>11</java.version> <!--Estou usando o 17-->
		<spring-cloud.version>2021.0.1</spring-cloud.version>
	</properties>

Notations: 

    @EnableEurekaServer (Na classe main)

Configurando Application.yml:

    Renomear o application.properties para application.yml

    #Vamos nomear - Pode quer qualquer nome
    spring:
    application:
        name: eurekaserver
        
    #Vamos configurar a porta    
    server:
    port: 8761

    #Dizendo ao eureka que não é para se auto-registrar, pois isso é papel do gateway
    eureka:
    client:
        register-with-eureka: false
        fetch-registry: false
  
Para acessar o eureka: http://localhost:8761

Aula 8 - 11
Criando Micro Serviço de Clientes:

Aqui vamos ter nossos endpoints do clieante

Dependências:

    Spring web
    Lombok
    Jpa
    H2 database

    Adicionais: Spring clould, Eureka client

Vamos padronixar nosso pom.xml

Vamos adicionar mais dependências no pom:

Dentro do escopo das dependências:

	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
	</dependency>

Abaixo do feclhamento da teg geral das dependências:

	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

Registrando micro serviço no eureka server

application.yml:

    #Nome que vamos refetencias o ms dentro do eureka
    spring:
    application:
        name: msclientes

    #A porta do nosso ms - A porta 0 quer dizer que vai subir em uma porta randômica para facilitar nosso trabalho de referenciar a porta    
    server:
    port: 0
    
    #Onde está meu discovery server eureka | o instance é para o spring gerar um nome aleatório do ms clientes
    eureka:
    client:
        service-url:
        defaultZone: http://localhost:8761/eureka
    instance:
        instance-id: ${spring.application.name}:${spring.application.instance_id:${random.value}} 


Notation (classe main):

    @EnableEurekaClient

Vamos criar nossa entidade (pct domain):

Notations:

    @Entity
    @Data //Lombok
    @NoArgsConstructor //Para tembém criar um construtor sem argumentos
    @Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)

Entidade:

    package io.github.cainamicael.msclientes.domain;

    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;

    import lombok.Data;
    import lombok.NoArgsConstructor;

    @Entity
    @Data
    @NoArgsConstructor
    public class Cliente {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        private String cpf;
        private String nome;
        private Integer idade;
        
        public Cliente(String cpf, String nome, Integer idade) {
            super();
            this.cpf = cpf;
            this.nome = nome;
            this.idade = idade;
        }
    }

Criando ClienteRepository (pct infra.repository):

    package io.github.cainamicael.msclientes.infra.repository;

    import java.util.Optional;

    import org.springframework.data.jpa.repository.JpaRepository;

    import io.github.cainamicael.msclientes.domain.Cliente;

    public interface ClienteRepository extends JpaRepository<Cliente, Long>{

        Optional<Cliente> findByCpf(String cpf); //Método que pedimos para criar

    }

Criando nosso DTO (pct application.representation):

    package io.github.cainamicael.msclientes.application.representation;

    import io.github.cainamicael.msclientes.domain.Cliente;
    import lombok.Data;
    import lombok.NoArgsConstructor;

    @Data
    @NoArgsConstructor
    public class ClienteSaveRequest {

        private String cpf;
        private String nome;
        private Integer idade;
        
        //Este método já transforma o dto em entidade
        public Cliente toModel() {
            return new Cliente(cpf, nome, idade);
        }
    }

Service:

    package io.github.cainamicael.msclientes.application;

    import java.util.Optional;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;

    import io.github.cainamicael.msclientes.domain.Cliente;
    import io.github.cainamicael.msclientes.infra.repository.ClienteRepository;

    @Service
    public class ClienteService {
        
        @Autowired
        private ClienteRepository repository;
        
        @Transactional
        public Cliente save(Cliente cliente) {
            return repository.save(cliente);
        }
        
        @Transactional
        public Optional<Cliente> getByCpf(String cpf){
            return repository.findByCpf(cpf);
        }
    }

Controller:

    package io.github.cainamicael.msclientes.application;

    import java.net.URI;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;
    import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

    import io.github.cainamicael.msclientes.application.representation.ClienteSaveRequest;
    import io.github.cainamicael.msclientes.domain.Cliente;

    @RestController
    @RequestMapping("clientes")
    public class ClientesController {
        
        @Autowired
        private ClienteService service;
        
        @GetMapping 
        public String status() { //Só para testar se está funcionando
            return "OK";
        }
        
        @PostMapping
        public ResponseEntity save(@RequestBody ClienteSaveRequest request) {
            Cliente cliente = request.toModel();
            service.save(cliente);
            
            
            //Construir uma url dinâmica através da url corrente - http://localhost:PORT/clientes?cpf=01234567890
            URI headerLocation = ServletUriComponentsBuilder
                    .fromCurrentRequest()
                    .query("cpf={cpf}")
                    .buildAndExpand(cliente.getCpf())
                    .toUri();

            return ResponseEntity.created(headerLocation).build();
        }

        @GetMapping(params = "cpf")
        public ResponseEntity<?> dadosCliente(@RequestParam("cpf") String cpf) {
            var cliente = service.getByCpf(cpf);
            
            if(cliente.isEmpty()) {
                return ResponseEntity.notFound().build();
            }
            
            return ResponseEntity.ok(cliente.get());
        }
    }

Métodos importantes:

    //Construir uma url dinâmica através da url corrente - http://localhost:PORT/clientes?cpf=01234567890
    URI headerLocation = ServletUriComponentsBuilder
            .fromCurrentRequest()
            .query("cpf={cpf}")
            .buildAndExpand(cliente.getCpf())
            .toUri();
    return ResponseEntity.created(headerLocation).build();

    //Este método já transforma o dto em entidade
        public Cliente toModel() {
            return new Cliente(cpf, nome, idade);
        }

Aula 12 - 13
Criação do Cloud Gateway:

Dependências:

    Spring Reactive Web (Webflux)
    Gateway
    Eureka Discovery Client

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>
    
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-gateway-dependencies</artifactId>
    </dependency>
    
    <dependency>
        <groupId>org.springframework.clould</groupId>
        <artifactId>spring-clould-starter-netflix-eureka-client</artifactId>
    </dependency>

Notation:

    @EnableEurekaClient (classe main)
    @EnableDiscoveryClient (classe main)
    @Bean (no método da classe main)

Classe main com roteamento:

    package io.github.cainamicael.msclouldgateway;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
    import org.springframework.cloud.gateway.route.RouteLocator;
    import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
    import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
    import org.springframework.context.annotation.Bean;

    @SpringBootApplication
    @EnableEurekaClient
    @EnableDiscoveryClient
    public class MscloudgatewayApplication {

        public static void main(String[] args) {
            SpringApplication.run(MsclouldgatewayApplication.class, args);
        }

        @Bean
        public RouteLocator routes(RouteLocatorBuilder builder) {
            return builder
                    .routes()
                    //Definindo rotas - Toda vez que a gente entrar nessa rota, vai ser redirecionado para a url (LoadBalancer do micro serviço), com o LoadBalancer
                    .route(r -> r.path("/clientes/**").uri("lb://msclientes")) //O ** quer dizer qq coisa que venha depois e lb é o loadbalancer
                    .build();
        }
    }

Application.yml:

    #Permite localizar os micro serviços e com letra maiuscula
    spring:
    application:
        name: mscloudgateway
    cloud:
        gateway:
        discovery:
            locator:
            enabled: true
            lower-case-service-id: true

    #Porta do Gateway
    server:
    port: 8080

    #Onde está o Eureka
    eureka:
    client:
        fetch-registry: true
        register-with-eureka: true
        service-url:
        defaultZone: http://localhost:8761/eureka

Agora podemos fazer as requisições para uma porta física, a 8080

Aula 14
Micro serviço de cartões:

Dependências:

    Lombok
    Spring Web
    Jpa
    H2 Database
    Eureka Client

Application.yml:

    #Nome da aplicação
    spring:
    application:
        name: mscartoes
        
    #Configurando porta
    server:
    port: 0
    
    #Localizando o eureka e setando nome com sufixo aleatorio - não pode esquecer do /eureka
    eureka:
    client:
        service-url:
        defaultZone: http://localhost:8761/eureka
    instance:
        instance-id: ${spring.application.name}:${spring.application.instance_id:${random.value}}

Colocar @EnableEurekaClient na classe main

Entidade:

    package io.github.cainamicael.mscartoes.domain;

    import java.math.BigDecimal;

    import javax.persistence.Entity;
    import javax.persistence.EnumType;
    import javax.persistence.Enumerated;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;

    import lombok.Data;
    import lombok.NoArgsConstructor;

    @Entity
    @Data
    @NoArgsConstructor
    public class Cartao {
        
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        private String nome;
        @Enumerated(EnumType.STRING)
        private BandeiraCartao bandeira; //Vai ser um enum
        private BigDecimal renda;
        private BigDecimal limiteBasico;
        
        public Cartao(String nome, BandeiraCartao bandeira, BigDecimal renda, BigDecimal limiteBasico) {
            super();
            this.nome = nome;
            this.bandeira = bandeira;
            this.renda = renda;
            this.limiteBasico = limiteBasico;
        }
    }

Notations: 

    @Entity
    @Data
    @NoArgsConstructor
    @Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
    @Enumerated(EnumType.STRING)

Enum:

    package io.github.cainamicael.mscartoes.domain;

    public enum BandeiraCartao {
        MASTERCARD, VISA
    }

Repository:

    package io.github.cainamicael.mscartoes.infra.repository;

    import org.springframework.data.jpa.repository.JpaRepository;

    import io.github.cainamicael.mscartoes.domain.Cartao;

    public interface CartaoRepository extends JpaRepository<Cartao, Long>{

        List<Cartao> findByRendaLessThanEqual(BigDecimal rendaBigDecimal);

    }

Service:

    package io.github.cainamicael.mscartoes.application;

    import java.math.BigDecimal;
    import java.util.List;

    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;

    import io.github.cainamicael.mscartoes.domain.Cartao;
    import io.github.cainamicael.mscartoes.infra.repository.CartaoRepository;
    import lombok.RequiredArgsConstructor;

    @Service
    @RequiredArgsConstructor
    public class CartaoService {
        
        private final CartaoRepository repository;
        
        @Transactional
        public Cartao save(Cartao cartao) {
            return repository.save(cartao);
        }
        
        @Transactional
        public List<Cartao> getCartoesRendaMenorIgual(Long renda) {
            var rendaBigBecimal = BigDecimal.valueOf(renda);
            return repository.findByRendaLesThanEqual(rendaBigBecimal);
        }
        
    }

Notations:

    @Service
    @RequiredArgsConstructor
    @Transactional

Outra forma de injetar dependência, sem usar o Autowired:

    @Service
    @RequiredArgsConstructor
    public class CartaoService {
        
        private final CartaoRepository repository;

    }

Resource(Controller):

