Ferramentas utilizadas: 

    Apache Maven
    JDK lts
    Docker
    IDE
    Insomnia HTTP

Aula 7
Criando nosso discovery server (Eureka):

Dependências:

    Eureka Server

Configrações importantes a principio do pom.xml:

	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>2.6.4</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>

	<properties>
		<java.version>11</java.version> <!--Estou usando o 17-->
		<spring-cloud.version>2021.0.1</spring-cloud.version>
	</properties>

Notations: 

    @EnableEurekaServer (Na classe main)

Configurando Application.yml:

    Renomear o application.properties para application.yml

    #Vamos nomear - Pode quer qualquer nome
    spring:
    application:
        name: eurekaserver
        
    #Vamos configurar a porta    
    server:
    port: 8761

    #Dizendo ao eureka que não é para se auto-registrar, pois isso é papel do gateway
    eureka:
    client:
        register-with-eureka: false
        fetch-registry: false
  
Para acessar o eureka: http://localhost:8761

Aula 8 - 11
Criando Micro Serviço de Clientes:

Aqui vamos ter nossos endpoints do clieante

Dependências:

    Spring web
    Lombok
    Jpa
    H2 database

    Adicionais: Spring clould, Eureka client

Vamos padronixar nosso pom.xml

Vamos adicionar mais dependências no pom:

Dentro do escopo das dependências:

	<dependency>
		<groupId>org.springframework.cloud</groupId>
		<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
	</dependency>

Abaixo do feclhamento da teg geral das dependências:

	<dependencyManagement>
		<dependencies>
			<dependency>
				<groupId>org.springframework.cloud</groupId>
				<artifactId>spring-cloud-dependencies</artifactId>
				<version>${spring-cloud.version}</version>
				<type>pom</type>
				<scope>import</scope>
			</dependency>
		</dependencies>
	</dependencyManagement>

Registrando micro serviço no eureka server

application.yml:

    #Nome que vamos refetencias o ms dentro do eureka
    spring:
    application:
        name: msclientes

    #A porta do nosso ms - A porta 0 quer dizer que vai subir em uma porta randômica para facilitar nosso trabalho de referenciar a porta    
    server:
    port: 0
    
    #Onde está meu discovery server eureka | o instance é para o spring gerar um nome aleatório do ms clientes
    eureka:
    client:
        service-url:
        defaultZone: http://localhost:8761/eureka
    instance:
        instance-id: ${spring.application.name}:${spring.application.instance_id:${random.value}} 


Notation (classe main):

    @EnableEurekaClient

Vamos criar nossa entidade (pct domain):

Notations:

    @Entity
    @Data //Lombok
    @NoArgsConstructor //Para tembém criar um construtor sem argumentos
    @Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)

Entidade:

    package io.github.cainamicael.msclientes.domain;

    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;

    import lombok.Data;
    import lombok.NoArgsConstructor;

    @Entity
    @Data
    @NoArgsConstructor
    public class Cliente {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        private String cpf;
        private String nome;
        private Integer idade;
        
        public Cliente(String cpf, String nome, Integer idade) {
            super();
            this.cpf = cpf;
            this.nome = nome;
            this.idade = idade;
        }
    }

Criando ClienteRepository (pct infra.repository):

    package io.github.cainamicael.msclientes.infra.repository;

    import java.util.Optional;

    import org.springframework.data.jpa.repository.JpaRepository;

    import io.github.cainamicael.msclientes.domain.Cliente;

    public interface ClienteRepository extends JpaRepository<Cliente, Long>{

        Optional<Cliente> findByCpf(String cpf); //Método que pedimos para criar

    }

Criando nosso DTO (pct application.representation):

    package io.github.cainamicael.msclientes.application.representation;

    import io.github.cainamicael.msclientes.domain.Cliente;
    import lombok.Data;
    import lombok.NoArgsConstructor;

    @Data
    @NoArgsConstructor
    public class ClienteSaveRequest {

        private String cpf;
        private String nome;
        private Integer idade;
        
        //Este método já transforma o dto em entidade
        public Cliente toModel() {
            return new Cliente(cpf, nome, idade);
        }
    }

Service:

    package io.github.cainamicael.msclientes.application;

    import java.util.Optional;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;

    import io.github.cainamicael.msclientes.domain.Cliente;
    import io.github.cainamicael.msclientes.infra.repository.ClienteRepository;

    @Service
    public class ClienteService {
        
        @Autowired
        private ClienteRepository repository;
        
        @Transactional
        public Cliente save(Cliente cliente) {
            return repository.save(cliente);
        }
        
        @Transactional
        public Optional<Cliente> getByCpf(String cpf){
            return repository.findByCpf(cpf);
        }
    }

Controller:

    package io.github.cainamicael.msclientes.application;

    import java.net.URI;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;
    import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

    import io.github.cainamicael.msclientes.application.representation.ClienteSaveRequest;
    import io.github.cainamicael.msclientes.domain.Cliente;

    @RestController
    @RequestMapping("clientes")
    public class ClientesController {
        
        @Autowired
        private ClienteService service;
        
        @GetMapping 
        public String status() { //Só para testar se está funcionando
            return "OK";
        }
        
        @PostMapping
        public ResponseEntity save(@RequestBody ClienteSaveRequest request) {
            Cliente cliente = request.toModel();
            service.save(cliente);
            
            
            //Construir uma url dinâmica através da url corrente - http://localhost:PORT/clientes?cpf=01234567890
            URI headerLocation = ServletUriComponentsBuilder
                    .fromCurrentRequest()
                    .query("cpf={cpf}")
                    .buildAndExpand(cliente.getCpf())
                    .toUri();

            return ResponseEntity.created(headerLocation).build();
        }

        @GetMapping(params = "cpf")
        public ResponseEntity<?> dadosCliente(@RequestParam("cpf") String cpf) {
            var cliente = service.getByCpf(cpf);
            
            if(cliente.isEmpty()) {
                return ResponseEntity.notFound().build();
            }
            
            return ResponseEntity.ok(cliente.get());
        }
    }

Métodos importantes:

    //Construir uma url dinâmica através da url corrente - http://localhost:PORT/clientes?cpf=01234567890
    URI headerLocation = ServletUriComponentsBuilder
            .fromCurrentRequest()
            .query("cpf={cpf}")
            .buildAndExpand(cliente.getCpf())
            .toUri();
    return ResponseEntity.created(headerLocation).build();

    //Este método já transforma o dto em entidade
        public Cliente toModel() {
            return new Cliente(cpf, nome, idade);
        }

Aula 12 - 13
Criação do Cloud Gateway:

Dependências:

    Spring Reactive Web (Webflux)
    Gateway
    Eureka Discovery Client

    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>
    
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-gateway-dependencies</artifactId>
    </dependency>
    
    <dependency>
        <groupId>org.springframework.clould</groupId>
        <artifactId>spring-clould-starter-netflix-eureka-client</artifactId>
    </dependency>

Notation:

    @EnableEurekaClient (classe main)
    @EnableDiscoveryClient (classe main)
    @Bean (no método da classe main)

Classe main com roteamento:

    package io.github.cainamicael.msclouldgateway;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;
    import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
    import org.springframework.cloud.gateway.route.RouteLocator;
    import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder;
    import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
    import org.springframework.context.annotation.Bean;

    @SpringBootApplication
    @EnableEurekaClient
    @EnableDiscoveryClient
    public class MscloudgatewayApplication {

        public static void main(String[] args) {
            SpringApplication.run(MsclouldgatewayApplication.class, args);
        }

        @Bean
        public RouteLocator routes(RouteLocatorBuilder builder) {
            return builder
                    .routes()
                    //Definindo rotas - Toda vez que a gente entrar nessa rota, vai ser redirecionado para a url (LoadBalancer do micro serviço), com o LoadBalancer
                    .route(r -> r.path("/clientes/**").uri("lb://msclientes")) //O ** quer dizer qq coisa que venha depois e lb é o loadbalancer
                    .build();
        }
    }

Application.yml:

    #Permite localizar os micro serviços e com letra maiuscula
    spring:
    application:
        name: mscloudgateway
    cloud:
        gateway:
        discovery:
            locator:
            enabled: true
            lower-case-service-id: true

    #Porta do Gateway
    server:
    port: 8080

    #Onde está o Eureka
    eureka:
    client:
        fetch-registry: true
        register-with-eureka: true
        service-url:
        defaultZone: http://localhost:8761/eureka

Agora podemos fazer as requisições para uma porta física, a 8080

Aula 14 - 18
Micro serviço de cartões:

Dependências:

    Lombok
    Spring Web
    Jpa
    H2 Database
    Eureka Client

Application.yml:

    #Nome da aplicação
    spring:
    application:
        name: mscartoes
        
    #Configurando porta
    server:
    port: 0
    
    #Localizando o eureka e setando nome com sufixo aleatorio - não pode esquecer do /eureka
    eureka:
    client:
        service-url:
        defaultZone: http://localhost:8761/eureka
    instance:
        instance-id: ${spring.application.name}:${spring.application.instance_id:${random.value}}

Colocar @EnableEurekaClient na classe main

Entidade:

    package io.github.cainamicael.mscartoes.domain;

    import java.math.BigDecimal;

    import javax.persistence.Entity;
    import javax.persistence.EnumType;
    import javax.persistence.Enumerated;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;

    import lombok.Data;
    import lombok.NoArgsConstructor;

    @Entity
    @Data
    @NoArgsConstructor
    public class Cartao {
        
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        private String nome;
        @Enumerated(EnumType.STRING)
        private BandeiraCartao bandeira; //Vai ser um enum
        private BigDecimal renda;
        private BigDecimal limiteBasico;
        
        public Cartao(String nome, BandeiraCartao bandeira, BigDecimal renda, BigDecimal limiteBasico) {
            super();
            this.nome = nome;
            this.bandeira = bandeira;
            this.renda = renda;
            this.limiteBasico = limiteBasico;
        }
    }

Notations: 

    @Entity
    @Data
    @NoArgsConstructor
    @Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
    @Enumerated(EnumType.STRING)

Enum:

    package io.github.cainamicael.mscartoes.domain;

    public enum BandeiraCartao {
        MASTERCARD, VISA
    }

Repository:

    package io.github.cainamicael.mscartoes.infra.repository;

    import org.springframework.data.jpa.repository.JpaRepository;

    import io.github.cainamicael.mscartoes.domain.Cartao;

    public interface CartaoRepository extends JpaRepository<Cartao, Long>{

        List<Cartao> findByRendaLessThanEqual(BigDecimal rendaBigDecimal);

    }

Service:

    package io.github.cainamicael.mscartoes.application;

    import java.math.BigDecimal;
    import java.util.List;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;

    import io.github.cainamicael.mscartoes.domain.Cartao;
    import io.github.cainamicael.mscartoes.infra.repository.CartaoRepository;

    @Service
    public class CartaoService {
        
        @Autowired
        private CartaoRepository repository;
        
        @Transactional
        public Cartao save(Cartao cartao) {
            return repository.save(cartao);
        }
        
        @Transactional
        public List<Cartao> getCartoesRendaMenorIgual(Long renda) {
            var rendaBigBecimal = BigDecimal.valueOf(renda);
            return repository.findByRendaLessThanEqual(rendaBigBecimal);
        }
        
    }

Notations:

    @Service
    @RequiredArgsConstructor
    @Transactional

Outra forma de injetar dependência, sem usar o Autowired:

    @Service
    @RequiredArgsConstructor
    public class CartaoService {
        
        private final CartaoRepository repository;

    }

Resource(Controller):

    package io.github.cainamicael.mscartoes.application;

    import java.util.List;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;

    import io.github.cainamicael.mscartoes.domain.Cartao;
    import io.github.cainamicael.mscartoes.representation.CartaoSavaRequest;

    @RestController
    @RequestMapping("cartoes")
    public class CartoesResource {
        
        @Autowired
        private CartaoService service;
        
        @GetMapping
        public String status() {
            return "OK";
        }
        
        @PostMapping
        public ResponseEntity<?> cadastra(@RequestBody CartaoSavaRequest request) {
            Cartao cartao = request.toModel();
            service.save(cartao);
            return ResponseEntity.status(HttpStatus.CREATED).build();
        }
        
        @GetMapping(params = "renda")
        public ResponseEntity<List<Cartao>> getCartoesRendaAte(@RequestParam("renda") Long renda ) {
            List<Cartao> list = service.getCartoesRendaMenorIgual(renda);
            return ResponseEntity.ok(list);
        }
    }

Aula 19:
Novo endpoint. Vamos precisar de uma nova entidade

Dizendo que cartão cada cliente vai ter:

Listando cartões pelo cliente:

Nova entidade, cartão cliente:

    package io.github.cainamicael.mscartoes.domain;

    import java.math.BigDecimal;

    import javax.persistence.Entity;
    import javax.persistence.GeneratedValue;
    import javax.persistence.GenerationType;
    import javax.persistence.Id;
    import javax.persistence.JoinColumn;
    import javax.persistence.ManyToOne;

    import lombok.Data;
    import lombok.NoArgsConstructor;

    @Entity
    @Data
    @NoArgsConstructor
    public class ClienteCartao {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        private Long id;
        private String cpf;
        
        @ManyToOne
        @JoinColumn(name = "id_cartao")
        private Cartao cartao;
        
        private BigDecimal limite;
    }

Repository:

    package io.github.cainamicael.mscartoes.infra.repository;

    import java.util.List;

    import org.springframework.data.jpa.repository.JpaRepository;

    import io.github.cainamicael.mscartoes.domain.ClienteCartao;

    public interface ClienteCartaoRepository extends JpaRepository<ClienteCartao, Long>{

        List<ClienteCartao> findByCpf(String cpf);
    }

Service:

    package io.github.cainamicael.mscartoes.application;

    import java.util.List;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;

    import io.github.cainamicael.mscartoes.domain.ClienteCartao;
    import io.github.cainamicael.mscartoes.infra.repository.ClienteCartaoRepository;

    @Service
    public class ClienteCartaoService {
        
        @Autowired
        private ClienteCartaoRepository repository;
        
        private List<ClienteCartao> listCartoesByCpf(String cpf) {
            return repository.findByCpf(cpf);
        }

    }

DTO CartaoPorClienteResponse:

    package io.github.cainamicael.mscartoes.representation;

    import java.math.BigDecimal;

    import io.github.cainamicael.mscartoes.domain.ClienteCartao;
    import lombok.AllArgsConstructor;
    import lombok.Data;
    import lombok.NoArgsConstructor;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public class CartaoPorClienteResponse {

        private String nome;
        private String bandeira;
        private BigDecimal limiteLiberado;
        
        public static CartaoPorClienteResponse fromModel(ClienteCartao model) {
            return new CartaoPorClienteResponse(
                model.getCartao().getNome(),
                model.getCartao().getBandeira().toString(),
                model.getLimite()
            );
        }
        
    }

Controller (Mesmo resource que já existe, só adicionar o método):

	@GetMapping(params = "cpf")
	public ResponseEntity<List<CartaoPorClienteResponse>> getCartoesByCliente(@RequestParam("cpf") String cpf) {
		List<ClienteCartao> lista = clienteCartaoService.listCartoesByCpf(cpf);
		List<CartaoPorClienteResponse> resultList = lista.stream().map(CartaoPorClienteResponse::fromModel).collect(Collectors.toList());
		return ResponseEntity.ok(resultList);
	}

Aula 20-25
Registrando MSCartoes no Gateway:

    .route(r -> r.path("/cartoes/**").uri("lb://mscartoes"))    

Aula 21
Implementando micro serviço avaliador de crédito, que vai se comunicar com os outros ms:

Dependências:

    Spring Web
    Lombok
    Eureka discovery client
    OpenFeign

Application.yml:

    spring:
    application:
        name: msavaliadorcredito
        
    server:
    port: 0
    
    eureka:
    client:
        service-url:
        defaultZone: http://localhost:8761/eureka
    instance:
        instance-id: ${spring.application.name}:${spring.application.instance_id:${random.value}}

Notation:

    @EnableEurekaClient(classe main)

Roteando no Gateway:

    .route(r -> r.path("/avaliacoes-credito/**").uri("lb://msavaliadorcredito"))

Configurando OpenFeign:

Notations:

    @EnableFeignClients(classe main)
    @FeignClient(url = "http://localhost:8080", path = "/clientes") //Na interface - este é só um exemplo. Esta notation não usa o loadbalancer. Vamos usar a notation Abaixo
    @FeignClient(value = "msclientes", path = "/clientes") //Estamos referenciando o ms e o endpoint

Interface (Que se comunica com o msclientes): 

    package cio.github.cainamicael.msavaliadorcredito.infra.clients;

    import org.springframework.cloud.openfeign.FeignClient;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestParam;

    import cio.github.cainamicael.msavaliadorcredito.domain.model.DadosCliente;

    @FeignClient(value = "msclientes", path = "/clientes") //Estamos referenciando o ms e o endpoint
    public interface ClienteResourceClient {
        
        //Só precisamos colocar a assinatura do método que vamos usar para obter os dados via endpoint
        @GetMapping(params = "cpf")
        ResponseEntity<DadosCliente> dadosCliente(@RequestParam("cpf") String cpf);

    }

Interface que se comunica com o mscartoes:

    package cio.github.cainamicael.msavaliadorcredito.infra.clients;

    import java.util.List;

    import org.springframework.cloud.openfeign.FeignClient;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestParam;

    import cio.github.cainamicael.msavaliadorcredito.domain.model.CartaoCliente;

    @FeignClient(value = "mscartoes", path = "/cartoes")
    public interface CartoesResourceClient {
        
        @GetMapping(params = "cpf")
        ResponseEntity<List<CartaoCliente>> getCartoesByCliente(@RequestParam("cpf") String cpf);

    }

Aula 26
Tratando erros da comunicação

Classe 1:

    package cio.github.cainamicael.msavaliadorcredito.application.ex;

    public class DadosClienteNotFoundException extends Exception{
        
        public DadosClienteNotFoundException() {
            super("Dados do cliente não encontrados para o cpf informado");
        }
        
    }

Classe 2:

    package cio.github.cainamicael.msavaliadorcredito.application.ex;

    import lombok.Getter;

    public class ErroComunicacaoMicroservicesException extends Exception {
        
        @Getter
        private Integer status;

        public ErroComunicacaoMicroservicesException(String msg, Integer status) {
            super(msg);
            this.status = status;
        }
    }

Service:

	public SituacaoCliente obterSituacaoCliente(String cpf) throws DadosClienteNotFoundException, ErroComunicacaoMicroservicesException {
		//precisamos consultar o msclientes para obter os dados - vamos usar OpenFeign
		
		//Comunicação síncrona com o mscliente
		try {
			ResponseEntity<DadosCliente> dadosClienteResponse = clienteClient.dadosCliente(cpf);
			
			//Comunicação síncrona com o mscartoes
			ResponseEntity<List<CartaoCliente>> cartoesResponse = cartoesClient.getCartoesByCliente(cpf);
			
			return SituacaoCliente
					.builder()
					.cliente(dadosClienteResponse.getBody())
					.cartoes(cartoesResponse.getBody())
					.build(); //Pegar apenas a informação do ResponseEntity	
		} catch (FeignException.FeignClientException e) {
			int status = e.status();
			
			if(HttpStatus.NOT_FOUND.value() == status) {
				throw new DadosClienteNotFoundException();
			}
			
			throw new ErroComunicacaoMicroservicesException(cpf, status);
		}
	}

Controller:

    @GetMapping(value = "situacao-cliente", params = "cpf")
	public ResponseEntity<?> consultaSituacaoCliente(@RequestParam("cpf") String cpf) {
		try {
			SituacaoCliente situacaoCliente = avaliadorCreditoService.obterSituacaoCliente(cpf);
			return ResponseEntity.ok(situacaoCliente);
			
		} catch (DadosClienteNotFoundException e) {
			// TODO Auto-generated catch block
			return ResponseEntity.notFound().build();
		} catch (ErroComunicacaoMicroservicesException e) {
			// TODO Auto-generated catch block
			return ResponseEntity.status(HttpStatus.resolve(e.getStatus())).body(e.getMessage());
		}
	}

Aula 27:
Implementando avaliação do cliente com regra de negócio:

Service:

    package cio.github.cainamicael.msavaliadorcredito.application;

    import java.math.BigDecimal;
    import java.util.List;
    import java.util.stream.Collectors;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.stereotype.Service;

    import cio.github.cainamicael.msavaliadorcredito.application.ex.DadosClienteNotFoundException;
    import cio.github.cainamicael.msavaliadorcredito.application.ex.ErroComunicacaoMicroservicesException;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.Cartao;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.CartaoAprovado;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.CartaoCliente;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.DadosCliente;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.RetornoAvaliacaoCliente;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.SituacaoCliente;
    import cio.github.cainamicael.msavaliadorcredito.infra.clients.CartoesResourceClient;
    import cio.github.cainamicael.msavaliadorcredito.infra.clients.ClienteResourceClient;
    import feign.FeignException;
    import lombok.RequiredArgsConstructor;

    @Service
    @RequiredArgsConstructor
    public class AvaliadorCreditoService {
        
        @Autowired
        private ClienteResourceClient clienteClient;
        
        @Autowired
        private CartoesResourceClient cartoesClient;

        
        public SituacaoCliente obterSituacaoCliente(String cpf) throws DadosClienteNotFoundException, ErroComunicacaoMicroservicesException {
            //precisamos consultar o msclientes para obter os dados - vamos usar OpenFeign
            
            //Comunicação síncrona com o mscliente
            try {
                ResponseEntity<DadosCliente> dadosClienteResponse = clienteClient.dadosCliente(cpf);
                
                //Comunicação síncrona com o mscartoes
                ResponseEntity<List<CartaoCliente>> cartoesResponse = cartoesClient.getCartoesByCliente(cpf);
                
                return SituacaoCliente
                        .builder()
                        .cliente(dadosClienteResponse.getBody())
                        .cartoes(cartoesResponse.getBody())
                        .build(); //Pegar apenas a informação do ResponseEntity	
            } catch (FeignException.FeignClientException e) {
                int status = e.status();
                
                if(HttpStatus.NOT_FOUND.value() == status) {
                    throw new DadosClienteNotFoundException();
                }
                
                throw new ErroComunicacaoMicroservicesException(cpf, status);
            }
        }
        
        public RetornoAvaliacaoCliente realizarAvaliacao (String cpf, Long renda) throws DadosClienteNotFoundException, ErroComunicacaoMicroservicesException {
            try {
                ResponseEntity<DadosCliente> dadosClienteResponse = clienteClient.dadosCliente(cpf);
                ResponseEntity<List<Cartao>> cartoesResponse = cartoesClient.getCartoesRendaAte(renda);
                
                List<Cartao> cartoes = cartoesResponse.getBody();
                List<CartaoAprovado> listaCartoesAprovados = cartoes.stream().map((Cartao cartao) -> {
                    DadosCliente dadosCliente = dadosClienteResponse.getBody();
                    BigDecimal limiteBasico = cartao.getLimiteBasico();
                    BigDecimal idadeBD = BigDecimal.valueOf(dadosCliente.getIdade());

                    var fator = idadeBD.divide(BigDecimal.valueOf(10));
                    BigDecimal limiteAprovado = fator.multiply(limiteBasico);

                    CartaoAprovado aprovado = new CartaoAprovado();
                    aprovado.setCartao(cartao.getNome());
                    aprovado.setBandeira(cartao.getBandeira());
                    aprovado.setLimiteAprovado(limiteAprovado);

                    return aprovado;
                }).collect(Collectors.toList());
                
                return new RetornoAvaliacaoCliente(listaCartoesAprovados);
            }  catch (FeignException.FeignClientException e) {
                int status = e.status();
                
                if(HttpStatus.NOT_FOUND.value() == status) {
                    throw new DadosClienteNotFoundException();
                }
        
                throw new ErroComunicacaoMicroservicesException(cpf, status);
            }
        }
    }

Controller:

    package cio.github.cainamicael.msavaliadorcredito.application;


    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RestController;

    import cio.github.cainamicael.msavaliadorcredito.application.ex.DadosClienteNotFoundException;
    import cio.github.cainamicael.msavaliadorcredito.application.ex.ErroComunicacaoMicroservicesException;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.DadosAvaliacao;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.RetornoAvaliacaoCliente;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.SituacaoCliente;

    @RestController
    @RequestMapping("avaliacoes-credito")
    public class AvaliadorCreditoController {
        
        @Autowired
        private AvaliadorCreditoService avaliadorCreditoService;
        
        @GetMapping
        public String status() {
            return "OK";
        }
        
        @GetMapping(value = "situacao-cliente", params = "cpf")
        public ResponseEntity<?> consultaSituacaoCliente(@RequestParam("cpf") String cpf) {
            try {
                SituacaoCliente situacaoCliente = avaliadorCreditoService.obterSituacaoCliente(cpf);
                return ResponseEntity.ok(situacaoCliente);
            } catch (DadosClienteNotFoundException e) {
                // TODO Auto-generated catch block
                return ResponseEntity.notFound().build();
            } catch (ErroComunicacaoMicroservicesException e) {
                // TODO Auto-generated catch block
                return ResponseEntity.status(HttpStatus.resolve(e.getStatus())).body(e.getMessage());
            }
        }
        
        @PostMapping
        public ResponseEntity realizarAvaliacao(@RequestBody DadosAvaliacao dados) {
            try {
                RetornoAvaliacaoCliente retornoAvaliacaoCliente = avaliadorCreditoService.realizarAvaliacao(dados.getCpf(), dados.getRenda());
                return ResponseEntity.ok(retornoAvaliacaoCliente);
            } catch (DadosClienteNotFoundException e) {
                // TODO Auto-generated catch block
                return ResponseEntity.notFound().build();
            } catch (ErroComunicacaoMicroservicesException e) {
                // TODO Auto-generated catch block
                return ResponseEntity.status(HttpStatus.resolve(e.getStatus())).body(e.getMessage());
            }	
        }
    }

Resource (FeignClient):

    package cio.github.cainamicael.msavaliadorcredito.infra.clients;

    import java.util.List;

    import org.springframework.cloud.openfeign.FeignClient;
    import org.springframework.http.ResponseEntity;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.RequestParam;

    import cio.github.cainamicael.msavaliadorcredito.domain.model.Cartao;
    import cio.github.cainamicael.msavaliadorcredito.domain.model.CartaoCliente;

    @FeignClient(value = "mscartoes", path = "/cartoes")
    public interface CartoesResourceClient {
        
        @GetMapping(params = "cpf")
        ResponseEntity<List<CartaoCliente>> getCartoesByCliente(@RequestParam("cpf") String cpf);
        
        @GetMapping(params = "renda")
        ResponseEntity<List<Cartao>> getCartoesRendaAte(@RequestParam("renda") Long renda);

    }

Mensageria:

Iremos usar o RabbitMQ

RabbitMQ via docker:

Scripc retirado do site do RabbitMQ:

docker run -it --rm --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.12-management

    docker run = Serve para rodar uma imagem docker - Cria um container
    -it = Modo interativo. Posso ficar interagindo com o container na linha de comando
    -rm = Quando eu encerrar o processo, ele vai destruir o container (Não vamos usar esta opção)
    --name rabbitmq = Dizendo que vou nomear o container, e em seguida já coloco o nome que eu quero
    -p 5672 (Porta exposta) : 5672 (Porta do container) = Dizendo que vai rodar em uma porta e expondo a porta
    -p 15672:15672 = Porta do administrador - Onde iremos acessar a interface gráfica
    rabbitmq:3.12-management = Imagem usada para startar o container

Ficará assim: docker run -it --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:3.12-management